#![no_main]
#![no_std]

use semihosting::process::exit;
use stm32h7xx_hal::{pac, prelude::*, spi};
use stm32h755zi as _;

const ARDUCHIP_TEST1: u8 = 0x00;
const ARDUCHIP_FIFO: u8 = 0x04;
const ARDUCHIP_TRIG: u8 = 0x41;
const ARDUCHIP_FIFO_SIZE1: u8 = 0x42;
const ARDUCHIP_FIFO_SIZE2: u8 = 0x43;
const ARDUCHIP_FIFO_SIZE3: u8 = 0x44;
const ARDUCHIP_BURST_FIFO_READ: u8 = 0x3C;

const SENSOR_ADDRESS: u8 = 0x30;

const OV2640_CHIPID_HIGH: u8 = 0x0A;
const OV2640_CHIPID_LOW: u8 = 0x0B;

const OV2640_QVGA: [[u8; 2]; 193] = [
    [0xff, 0x0],
    [0x2c, 0xff],
    [0x2e, 0xdf],
    [0xff, 0x1],
    [0x3c, 0x32],
    [0x11, 0x0],
    [0x9, 0x2],
    [0x4, 0xa8],
    [0x13, 0xe5],
    [0x14, 0x48],
    [0x2c, 0xc],
    [0x33, 0x78],
    [0x3a, 0x33],
    [0x3b, 0xfb],
    [0x3e, 0x0],
    [0x43, 0x11],
    [0x16, 0x10],
    [0x39, 0x2],
    [0x35, 0x88],
    [0x22, 0xa],
    [0x37, 0x40],
    [0x23, 0x0],
    [0x34, 0xa0],
    [0x6, 0x2],
    [0x6, 0x88],
    [0x7, 0xc0],
    [0xd, 0xb7],
    [0xe, 0x1],
    [0x4c, 0x0],
    [0x4a, 0x81],
    [0x21, 0x99],
    [0x24, 0x40],
    [0x25, 0x38],
    [0x26, 0x82],
    [0x5c, 0x0],
    [0x63, 0x0],
    [0x46, 0x22],
    [0xc, 0x3a],
    [0x5d, 0x55],
    [0x5e, 0x7d],
    [0x5f, 0x7d],
    [0x60, 0x55],
    [0x61, 0x70],
    [0x62, 0x80],
    [0x7c, 0x5],
    [0x20, 0x80],
    [0x28, 0x30],
    [0x6c, 0x0],
    [0x6d, 0x80],
    [0x6e, 0x0],
    [0x70, 0x2],
    [0x71, 0x94],
    [0x73, 0xc1],
    [0x3d, 0x34],
    [0x12, 0x4],
    [0x5a, 0x57],
    [0x4f, 0xbb],
    [0x50, 0x9c],
    [0xff, 0x0],
    [0xe5, 0x7f],
    [0xf9, 0xc0],
    [0x41, 0x24],
    [0xe0, 0x14],
    [0x76, 0xff],
    [0x33, 0xa0],
    [0x42, 0x20],
    [0x43, 0x18],
    [0x4c, 0x0],
    [0x87, 0xd0],
    [0x88, 0x3f],
    [0xd7, 0x3],
    [0xd9, 0x10],
    [0xd3, 0x82],
    [0xc8, 0x8],
    [0xc9, 0x80],
    [0x7c, 0x0],
    [0x7d, 0x0],
    [0x7c, 0x3],
    [0x7d, 0x48],
    [0x7d, 0x48],
    [0x7c, 0x8],
    [0x7d, 0x20],
    [0x7d, 0x10],
    [0x7d, 0xe],
    [0x90, 0x0],
    [0x91, 0xe],
    [0x91, 0x1a],
    [0x91, 0x31],
    [0x91, 0x5a],
    [0x91, 0x69],
    [0x91, 0x75],
    [0x91, 0x7e],
    [0x91, 0x88],
    [0x91, 0x8f],
    [0x91, 0x96],
    [0x91, 0xa3],
    [0x91, 0xaf],
    [0x91, 0xc4],
    [0x91, 0xd7],
    [0x91, 0xe8],
    [0x91, 0x20],
    [0x92, 0x0],
    [0x93, 0x6],
    [0x93, 0xe3],
    [0x93, 0x3],
    [0x93, 0x3],
    [0x93, 0x0],
    [0x93, 0x2],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x93, 0x0],
    [0x96, 0x0],
    [0x97, 0x8],
    [0x97, 0x19],
    [0x97, 0x2],
    [0x97, 0xc],
    [0x97, 0x24],
    [0x97, 0x30],
    [0x97, 0x28],
    [0x97, 0x26],
    [0x97, 0x2],
    [0x97, 0x98],
    [0x97, 0x80],
    [0x97, 0x0],
    [0x97, 0x0],
    [0xa4, 0x0],
    [0xa8, 0x0],
    [0xc5, 0x11],
    [0xc6, 0x51],
    [0xbf, 0x80],
    [0xc7, 0x10],
    [0xb6, 0x66],
    [0xb8, 0xa5],
    [0xb7, 0x64],
    [0xb9, 0x7c],
    [0xb3, 0xaf],
    [0xb4, 0x97],
    [0xb5, 0xff],
    [0xb0, 0xc5],
    [0xb1, 0x94],
    [0xb2, 0xf],
    [0xc4, 0x5c],
    [0xa6, 0x0],
    [0xa7, 0x20],
    [0xa7, 0xd8],
    [0xa7, 0x1b],
    [0xa7, 0x31],
    [0xa7, 0x0],
    [0xa7, 0x18],
    [0xa7, 0x20],
    [0xa7, 0xd8],
    [0xa7, 0x19],
    [0xa7, 0x31],
    [0xa7, 0x0],
    [0xa7, 0x18],
    [0xa7, 0x20],
    [0xa7, 0xd8],
    [0xa7, 0x19],
    [0xa7, 0x31],
    [0xa7, 0x0],
    [0xa7, 0x18],
    [0x7f, 0x0],
    [0xe5, 0x1f],
    [0xe1, 0x77],
    [0xdd, 0x7f],
    [0xc2, 0xe],
    [0xff, 0x0],
    [0xe0, 0x4],
    [0xc0, 0xc8],
    [0xc1, 0x96],
    [0x86, 0x3d],
    [0x51, 0x90],
    [0x52, 0x2c],
    [0x53, 0x0],
    [0x54, 0x0],
    [0x55, 0x88],
    [0x57, 0x0],
    [0x50, 0x92],
    [0x5a, 0x50],
    [0x5b, 0x3c],
    [0x5c, 0x0],
    [0xd3, 0x4],
    [0xe0, 0x0],
    [0xff, 0x0],
    [0x5, 0x0],
    [0xda, 0x8],
    [0xd7, 0x3],
    [0xe0, 0x0],
    [0x5, 0x0],
];

const BMP_HEADER: [u8; 66] = [
    // BMP header : 14 bytes
    0x42, 0x4D, // BM
    0x42, 0x58, 0x02, 0x00, // Size : 153666 bytes
    0x00, 0x00, // Application
    0x00, 0x00, // Application
    0x42, 0x00, 0x00, 0x00, // Offset : 66 bytes
    // DIB Header : 52 bytes
    0x28, 0x00, 0x00, 0x00, // DIB Header size : 40 bytes
    0x40, 0x01, 0x00, 0x00, // Image width : 320 px
    0xF0, 0x00, 0x00, 0x00, // Image height : 240 px
    0x01, 0x00, // Color plane : 1
    0x10, 0x00, // Bits per pixel : 16 bits
    0x03, 0x00, 0x00, 0x00, // Compression method : 3 (BITFIELDS)
    0x00, 0x58, 0x02, 0x00, // Raw Bitmap size : 153600 bytes
    0xC4, 0x0E, 0x00, 0x00, // Horizontal resolution : 3780 px/m
    0xC4, 0x0E, 0x00, 0x00, // Vertical resolution : 3780 px/m
    0x00, 0x00, 0x00, 0x00, // Colors in palette : 0 (256)
    0x00, 0x00, 0x00, 0x00, // Importants colors : 0
    // Bit masks
    0x00, 0xF8, 0x00, 0x00, // Red mask :   1111 1000  0000 0000
    0xE0, 0x07, 0x00, 0x00, // Green mask : 0000 0111  1110 0000
    0x1F, 0x00, 0x00, 0x00, // Blue mask :  0000 0000  0001 1111
];

macro_rules! i2c_read {
    ($i2c:ident, $reg:expr) => {{
        let mut value = [0u8];
        $i2c.write_read(SENSOR_ADDRESS, &[$reg], &mut value)
            .expect("I2C read");
        value[0]
    }};
}

macro_rules! i2c_write {
    ($i2c:ident, $reg:expr, $val:expr) => {
        $i2c.write(SENSOR_ADDRESS, &[$reg, $val])
            .expect("I2C write");
    };
}

macro_rules! spi_read {
    ($spi:ident, $cs:ident, $reg:expr) => {{
        $cs.set_low();
        $spi.write(&[$reg]).expect("SPI write");
        let value = $spi.transfer(&mut [0u8]).expect("SPI read")[0];
        $cs.set_high();
        value
    }};
}

macro_rules! spi_write {
    ($spi:ident, $cs:ident, $reg:expr, $val:expr) => {
        $cs.set_low();
        $spi.write(&[$reg | 0x80, $val]).expect("SPI write");
        $cs.set_high();
    };
}

macro_rules! clear_fifo_flag {
    ($spi:ident, $cs:ident) => {
        spi_write!($spi, $cs, ARDUCHIP_FIFO, 0x01)
    };
}

macro_rules! start_capture {
    ($spi:ident, $cs:ident) => {
        spi_write!($spi, $cs, ARDUCHIP_FIFO, 0x02)
    };
}

macro_rules! capture_done {
    ($spi:ident, $cs:ident) => {{ spi_read!($spi, $cs, ARDUCHIP_TRIG) & 0x08 != 0 }};
}

macro_rules! read_fifo_flag {
    ($spi:ident, $cs:ident) => {{
        ((spi_read!($spi, $cs, ARDUCHIP_FIFO_SIZE3) as u32) << 16
            | (spi_read!($spi, $cs, ARDUCHIP_FIFO_SIZE2) as u32) << 8
            | (spi_read!($spi, $cs, ARDUCHIP_FIFO_SIZE1) as u32))
            & 0x7fffff
    }};
}

macro_rules! burst_fifo_read {
    ($spi:ident, $cs:ident, $length:expr) => {
        $cs.set_low();
        $spi.write(&[ARDUCHIP_BURST_FIFO_READ]).expect("SPI write");
        for v in BMP_HEADER {
            defmt::println!("{=u8:02X}", v);
        }
        for _ in 0..153600 / 2 {
            let vh = $spi.transfer(&mut [0u8]).expect("SPI read")[0];
            defmt::println!("{=u8:02X}", $spi.transfer(&mut [0u8]).expect("SPI read")[0]);
            defmt::println!("{=u8:02X}", vh);
        }
        $cs.set_high();
    };
}
#[cortex_m_rt::entry]
fn main() -> ! {
    let cp = cortex_m::Peripherals::take().unwrap();
    let dp = pac::Peripherals::take().unwrap();

    // Power
    let pwrcfg = dp.PWR.constrain().freeze();

    // Clock
    let ccdr = dp
        .RCC
        .constrain()
        .sys_ck(96.MHz())
        .pll1_q_ck(48.MHz())
        .freeze(pwrcfg, &dp.SYSCFG);

    // GPIO
    let gpioa = dp.GPIOA.split(ccdr.peripheral.GPIOA);
    let gpiob = dp.GPIOB.split(ccdr.peripheral.GPIOB);
    let gpiod = dp.GPIOD.split(ccdr.peripheral.GPIOD);

    // Pins
    let sck = gpioa.pa5.into_alternate();
    let miso = gpioa.pa6.into_alternate();
    let mosi = gpiob.pb5.into_alternate();
    let mut cs = gpiod.pd15.into_push_pull_output();
    cs.set_high();

    let scl = gpiob.pb6.into_alternate_open_drain();
    let sda = gpiob.pb7.into_alternate_open_drain();

    let mut delay = cp.SYST.delay(ccdr.clocks);

    let mut spi: spi::Spi<pac::SPI1, _, u8> = dp.SPI1.spi(
        (sck, miso, mosi),
        spi::MODE_0,
        3.MHz(),
        ccdr.peripheral.SPI1,
        &ccdr.clocks,
    );
    let mut i2c = dp
        .I2C1
        .i2c((scl, sda), 100.kHz(), ccdr.peripheral.I2C1, &ccdr.clocks);

    // ArduCAM reset
    spi_write!(spi, cs, 0x07, 0x80);
    delay.delay_ms(100_u16);
    spi_write!(spi, cs, 0x07, 0x00);
    delay.delay_ms(100_u16);

    // SPI Test
    spi_write!(spi, cs, ARDUCHIP_TEST1, 0x55);
    //defmt::println!("SPI_TEST = 0x{=u8:X}", spi_read!(spi, cs, ARDUCHIP_TEST1));

    // I2C Test
    i2c_write!(i2c, 0xFF, 0x01);
    //defmt::println!("VID = 0x{=u8:X}", i2c_read!(i2c, OV2640_CHIPID_HIGH));
    //defmt::println!("PID = 0x{=u8:X}", i2c_read!(i2c, OV2640_CHIPID_LOW));

    // Camera Init
    i2c_write!(i2c, 0xFF, 0x01);
    i2c_write!(i2c, 0x12, 0x80);
    delay.delay_ms(100_u16);

    // Camera config
    for [reg, val] in OV2640_QVGA {
        i2c_write!(i2c, reg, val);
    }
    delay.delay_ms(1000_u16);

    // Take photo
    clear_fifo_flag!(spi, cs);
    start_capture!(spi, cs);
    //defmt::println!("Capture start");

    while !capture_done!(spi, cs) {
        delay.delay_ms(10_u16);
    }
    //defmt::println!("Capture done");
    delay.delay_ms(50_u16);

    let length = read_fifo_flag!(spi, cs);
    //defmt::println!("FIFO length = {}", length);

    if length >= 153600 {
        burst_fifo_read!(spi, cs, length);
    }

    exit(0)
}
